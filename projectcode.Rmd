---
title: "Group-L-Project"
author: "Laknath Dias Gunathilake"
date: "March 13, 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Exploration  


```{r }
library(rpart) # added tree library
library(partykit)
library(ggplot2)
library(gridExtra)
library(dplyr)
library(ggcorrplot)
library(randomForest)

library(ggcorrplot)

df <- read.csv("network_traffic.csv")

p1 <- qplot(df$duration, geom="histogram")
p2 <- qplot(df$protocol_type, geom="bar")
p3 <- qplot(df$service, geom="bar")
p4 <- qplot(df$src_bytes, geom="histogram")
p5 <- qplot(df$dst_bytes, geom="histogram")
p6 <- qplot(df$flag, geom="bar")
p7 <- qplot(df$land, geom="bar")
p8 <- qplot(df$wrong_fragment, geom="histogram")
p9 <- qplot(df$urgent, geom="histogram")
p10 <- qplot(df$hot, geom="histogram")
p11 <- qplot(df$num_failed_logins, geom="histogram")
p12 <- qplot(df$logged_in, geom="bar")
p13 <- qplot(df$num_compromised, geom="histogram")
p14 <- qplot(df$root_shell, geom="bar")
p15 <- qplot(df$su_attempted, geom="bar")
p16 <- qplot(df$num_root, geom="histogram")
p17 <- qplot(df$num_file_creations, geom="histogram")
p18 <- qplot(df$num_shells, geom="histogram")
p19 <- qplot(df$num_access_files, geom="histogram")
p20 <- qplot(df$num_outbound_cmds, geom="histogram")
p21 <- qplot(df$is_hot_login, geom="bar")
p22 <- qplot(df$is_guest_login, geom="bar")
p23 <- qplot(df$is_intrusion, geom="bar")
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p12, p13, ncol=3)
grid.arrange(p14, p15, p16, p17, p18, p19, p20, p21, p22, p23, ncol=3)
```

```{r}
# drop useless columns
df <- select(df, -c(num_outbound_cmds, land, num_failed_logins, wrong_fragment, urgent, is_host_login, su_attempted))

# Clean is_intrusion column
df$is_intrusion <- ifelse(df$is_intrusion == 1, 1, 0)

# convert to factors
df$is_intrusion <- as.factor(df$is_intrusion)
df$protocol_type <- as.factor(df$protocol_type)
df$service <- as.factor(df$service)
df$flag <- as.factor(df$flag)
df$logged_in <- as.factor(df$logged_in)
df$root_shell <- as.factor(df$root_shell)
df$is_guest_login <- as.factor(df$is_guest_login)

summary(df)
```

# Class Metrics
```{r}
classMetrics <- function(score, y, cutoff, 
                         type = c("all", "accuracy", "sensitivity", 
                                  "specificity", "ppv", "npv", "precision", 
                                  "recall")) {
  
              
  # classify the observations based on score and cutoff
  observed <- y
  predicted <- ifelse(score >= cutoff,1,0)
  
      # Form confusion matrix
  conf<-table(predicted,observed)
  
  # Use the appropriate entries in the confusion matrix to calculate all metrics:
  # accuracy, sensitivity, specificity, ppv, npv, precision (which is the same as ppv), recall (which is the same as sensitivity)
  #accuracy <-
  
  accuracy<- round((conf[4]+conf[1])/sum(conf),6)
  sensitivity <- (conf[4])/(conf[3]+conf[4])
  specificity <-  conf[1]/(conf[1]+conf[2])
  ppv         <- conf[4]/(conf[4]+conf[2])
  npv         <- conf[1]/(conf[1]+conf[3])
  precision   <- ppv
  recall      <- sensitivity
  
  # I'm giving you the exact names you should use in your output dataframe  
  metric.names <- c("accuracy", "sensitivity", "specificity", 
                    "ppv", "npv", "precision", "recall")

  # Form into data frame
  value <- c(accuracy, sensitivity, specificity, 
                    ppv, npv, precision, recall)
  
  
  
  # Your data frame should contain ONLY ONE COLUMN named "value"
  # assign the metric.names above as the rownames of your data frame (just as the rownames, not as a second column!)
  df <- data.frame(row.names = metric.names,value)
  
  full_list<- list(conf,df)
  names(full_list) <- c("conf.mat", "perf")
  #full_list <<- full_list
  # Return a list containing the confusion matrix and the data frame of the metrics
  # If "all", return all metrics. Otherwise, return just the requested subset of metrics
  if ("all" %in% type){
    return(full_list)
  } else {
    full_list[[2]]<- full_list[[2]]%>%
          filter(row.names(full_list[[2]]) %in% type)
    return(full_list)
  }
}

```







Decision Trees, upsampling and creating train and test set
```{r}


# Upsample the data to artifically overcome sample imbalance
df.more.idx <- sample(which(df$is_intrusion == 1), 15000, replace = TRUE)
df.upsample <- rbind(df,
                        df[df.more.idx, ])



# Randomly select 20% of the data to be held out for model validation
test.indexes <- sample(1:nrow(df.upsample), 
                       round(0.2 * nrow(df.upsample)))
train.indexes <- setdiff(1:nrow(df.upsample), test.indexes)

df.train <- df.upsample[train.indexes, c(1:15, 16)]
df.test <- df.upsample[test.indexes, c(1:15, 16)]



```


# Training the tree
```{r}
intrusion.tree<- rpart(is_intrusion ~ ., df.train)


plot(intrusion.tree)
text(intrusion.tree)

intrusion.party <- as.party(intrusion.tree)

plot(intrusion.party)
```


#Testing the Tree
```{r}
intrusion.full <- rpart(is_intrusion ~ ., data = df.train, 
                        control = rpart.control(minsplit=100, cp=0.002))

# Run the `plotcp` command on this tree. Also look at the `cptable` attribute of `marketing.full`
plotcp(intrusion.full)

intrusion.full$cptable

mycp <- 0.002000000 

intrusion.pruned<- prune(intrusion.full,cp= mycp)


print(intrusion.pruned)

```

# Pruned Tree
```{r}
df.pruned.party <- as.party(intrusion.pruned)
plot(df.pruned.party, gp = gpar(fontsize = 7))

```


# Using the pruned tree on the test dataset
```{r}

my_pred<- predict(intrusion.pruned, marketing.test, type="prob")
classMetrics(my_pred[,1], df.test$is_intrusion,cutoff = 0.25)

```

# Building a Random forest 
```{r}
intrusion.rf <- randomForest(is_intrusion ~.,data=df.train, importance=TRUE)

varImpPlot (intrusion.rf)
```

```{r}
my_pred_forest<- predict(intrusion.rf,df.test,type="prob")



classMetrics(my_pred_forest[,1], df.test$is_intrusion,cutoff = 0.3) 
classMetrics(my_pred_forest[,1], df.test$is_intrusion,cutoff = 0.25) 


```

=======
```{r}
# Prepare data for modeling

# upsample
df.more.idx <- sample(which(df$is_intrusion == "yes"), 2700, replace = TRUE)
df.upsample <- rbind(df, df[df.more.idx, ])

# train/test split
test.indexes <- sample(1:nrow(df), round(0.2 * nrow(df)))
train.indexes <- setdiff(1:nrow(df), test.indexes)
df.train <- df[train.indexes,]
df.test <- df[test.indexes,]
```

```{r}
# Logistic Regression

# fit logistic regression on train set
glm.fits <- glm(is_intrusionâˆ¼., data=df.train ,family=binomial)
summary(glm.fits)

# predict on test set
glm.probs <- predict(glm.fits,df.test , type="response")

cutoff <- 0.5
glm.pred <- 1:length(glm.probs)
glm.pred[glm.probs > cutoff] <- 1
glm.pred[glm.probs < cutoff] <- 0

table(glm.pred, df.test$is_intrusion)
```

```{r}
#KNN

```
